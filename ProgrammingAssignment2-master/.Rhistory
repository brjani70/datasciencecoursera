install.packages("devtools")
library(devtools)
find_rtools()
install.packages("KernSmooth")
KernSmooth
install.packages("rmarkdown")
if(x > 3) {
y <- 10
} else {
y <- 0
}
add2 <- function(x, y) {
x + y
}
add2(3,5)
above <- function(x, n) {
use <- x > n
x[use]
}
x<- 1:20
above(x,12)
above <- function(x, n = 10) {
use <- x > n
x[use]
}
above(x)
columnmean <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <0 mean(y[, i])
}
means
}
columnmean <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(y[, i])
}
means
}
columnmean <- function(y, removeNA = TRUE) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(y[, i], na.rm=removeNA)
}
means
}
swirl()
library(swirl)
swirl()
submit()
submit()
submit()
submit()
submit()
submit()
mad_libs <- function(...){
# Do your argument unpacking here!
args <- list(...)
place <- args[["place"]]
adjective <- args[["adjective"]]
# Don't modify any code below this comment.
# Notice the variables you'll need to create in order for the code below to
# be functional!
paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}
submit()
submit()
submit()
submit()
?info()
info()
swirl()
submit()
submit()
mad_libs <- function(...){
# Do your argument unpacking here!
args <- list(...)
place <- args[["place"]]
adjective <- args[["adjective"]]
noun <- args[["noun"]]
# Don't modify any code below this comment.
# Notice the variables you'll need to create in order for the code below to
# be functional!
paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}
mad_libs(place = "London", adjective = "beautiful", noun = "dog")
info()
skip()
mad_libs(place = "pikachu", adjective = "pickachew", noun = "peekaachoooo")
submit()
"Good" %p% "job"
"%p%" <- function(left, right){ # Remember to add arguments!
paste(left, right)
}
"Good" %p% "job"
submit()
submit()
"Hello" %p% "student"
"%p%" <- function(left, right){ # Remember to add arguments!
paste(left, right)
}
"Hello" %p% "student"
submit()
submit()
"I" %p% "love" %p% "R"
"I" %p% "love" %p% "R!"
bye()
library(datasets)
data(iris)
?iris
lapply(iris$Sepal.Length, mean)
View(iris)
lapply(iris, mean)
?index
?index()
[]
?[]
?gl()
?iris
tapply(iris$Sepal.Length, iris$Species, mean)
apply(iris[, 1:4], 2, mean)
library(mtcars)
data(mtcars)
?mtcars
sapply(mtcars, cyl, mean)
?mean()
mean(mtcars$mpg, mtcars$cyl)
?split()
split(mtcars, mtcars$cyl)
with(mtcars, tapply(mpg, cyl, mean))
tapply(mtcars$mpg, mtcars$cyl, mean)
split(mtcars$mpg, mtcars$cyl)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
?tapply(0)
lapply(mtcars, mean)
tapply(mtcars$hp, mtcars$cyl, mean)
209.21429 - 82.63636
debug(ls)
ls
ls()
getwd()
getwd
getwd()
setwd("C:\Users\brjani70\Desktop\Coursera R\ProgrammingAssignment2-master")
setwd("C:/Users/brjani70/Desktop/Coursera R/ProgrammingAssignment2-master")
## Put comments here that give an overall description of what your
## functions do
#### Brijesh Comments: These functions will cache the inverse of a matrix,
####                   as per the assignment description.
## Write a short comment describing this function
#### Brijesh Comments: This function creates a special "matrix" object
####                   that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(inverse_final) inverse <<- inverse_final
getinverse <- function() inverse
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
#### Brijesh Comments: This function computes the inverse of the special
####                   "matrix" returned by makeCacheMatrix.
cacheSolve <- function(x, ...) {
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <- x$get()
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse
}
matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get(0)
my_matrix$get()
## Put comments here that give an overall description of what your
## functions do
#### Brijesh Comments: These functions will cache the inverse of a matrix,
####                   as per the assignment description.
## Write a short comment describing this function
#### Brijesh Comments: This function creates a special "matrix" object
####                   that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(inverse_final) inverse <<- inverse_final
getinverse <- function() inverse
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
#### Brijesh Comments: This function computes the inverse of the special
####                   "matrix" returned by makeCacheMatrix.
cacheSolve <- function(x, ...) {
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <- x$get()
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse
}
matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
matrix$get()
matrix$getinverse()
cacheSolve(matrix)
cacheSolve(matrix)
